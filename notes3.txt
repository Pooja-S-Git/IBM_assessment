1.) TestNG :- TestNG is a testing framework that is capable of making Selenium tests easier to understand and of generating reports that are easy to understand.

TestNG is an automation testing framework in which NG stands for “Next Generation”. TestNG is inspired by JUnit which uses the annotations (@). TestNG overcomes the disadvantages of JUnit and is designed to make end-to-end testing easy.
Using TestNG, you can generate a proper report, and you can easily come to know how many test cases are passed, failed, and skipped. You can execute the failed test cases separately.	

TestNG Annotations are used to control the next method to be executed in the test script. TestNG annotations are defined before every method in the test code.

2.) advantages of TestNG over JUnit:

-- Annotations are easier to understand
-- Test cases can be grouped more easily
-- Parallel testing is possible
-- TestNG is capable of generating HTML-based reports.
-- Annotations can use parameters
-- TestNG Dataprovider is a way to pass parameters into the test function which passes different values in test cases in a single execution.

3.) steps
-- install TestNG from Eclipse workspace
-- Install jar files for java & dependency in maven project

3.)  @Test  -- Run All  & Run|Debug

testng xml --- is a config file , what we want to execute and which order we want to execute , how many times 

4.)  Asserts --it is static class, It's a class file provided by TestNG
  Assertion -- 

methods :
assertEquals
assertNotEquals
assertTrue	(antwhere u r getting boolean values from websites u can check those by this methods)
assertFalse
assertNull   (for object  , as obj created or other obj to check they are null or not)
assertNotNull

5)  types  :-  hard &  soft
	hard -- means assert
	soft --  assertAll() to throw exception

.Annotations :- (@) Annotations in TestNG are lines of code that can control how the method below them will be executed.

@BeforeSuite
@AfterSuite
@BeforeClass
@AfterClass
@BeforeMethod
@AfterMethod
@BeforeTest
@AfterTest
@BeforeGroup
@AfterGroup

@DataProvider
@Parameters


. @Test:  TestCases and Main method

. @BeforeMethod: This will be executed before every @test annotated method.

. @AfterMethod: This will be executed after every @test annotated method.

. @BeforeClass: This will be executed before first @Test method execution. It will be executed one only time throughout the   	test case.

. @AfterClass: This will be executed after all test methods in the current class have been run

. @BeforeTest: This will be executed before the first @Test annotated method. It can be executed multiple times before the   		test case.

. @AfterTest: A method with this annotation will be executed when all @Test annotated methods complete the execution of those   classes inside the <test> tag in the TestNG.xml file.

. @BeforeSuite: It will run only once, before all tests in the suite are executed.

. @AfterSuite: A method with this annotation will run once after the execution of all tests in the suite is complete.

. @BeforeGroups: This method will run before the first test run of that specific group.

. @AfterGroups: This method will run after all test methods of that group complete their execution.

==============
@dataProvider:
	To pass the different datas for same test case
	return type of data provider is 2 dimensional array
	if you want to access the data provider outside the class mention the data provider as static.
===============
. @parameters: 
	-- when you want to pass the input from XML
	-- @parameters annotation needs to be used

-- @optional 
In this annotation, if the defined parameter is not found in the testng.xml file, Then Test method will receive the default value from the @Optional annotation.When parameters name is not matched , then we give @optional. you have to pass the value at the time of initialization  , public void log(@Optional("name")String username)

-- If both @parameters and @optional are used , where parameters name is matched , then preference will be given to 	parameter value
================
. priority: (priority = 1) or (priority = -1)
	we can pass priority to the particular testcases
	we can pass negative & positive values
	It will execute based on the ascending order
	If we give same priority then it will execute based on the alphabetic order.
================
. Ignoring the testcases: (enabled = false)
	for ignoring the testcases , we can use one method called enabled
	when the enabled = false , It will skip the particular testcases
================
. Invocation count: (invocationCount = 2)
	If u want run the particular testcases for n number of times , we can use one method called innvocation class
	It will run the testcases for that particular times
============================
. depends on method 

. timeout : The maximum time a test execution should take. If exceeded, the test fails automatically. (timeOut = 6000)

. expectedExceptions:-
expectedExceptions = NoSuchElementException.class
expectedExceptions Is very good feature of testng using which we can Ignore known but not required exceptions. In your selenium webdriver test execution, You can use expectedExceptions when you know that any specific @Test method can throw specific exception but It Is not much more Important and you wants to Ignore that exception.

If you have used expectedExceptions attribute with @Test method then Whenever Exceptions thrown In @Test method, It will compare It with expectedExceptions attribute's value. If both match then It will be handled by TestNG. That means your @Test method will be pass and remaining part of that method will be skipped.
=========================
Parallel: Parallel testing or parallel execution, as the name suggests, is a process of running the test case parallelly rather than one after the other.   In parallel testing, the program's multiple parts (or modules) execute together, saving the testers a lot of time and effort. (Fails On Dependent Modules)Parallel testing allows independent running of modules simultaneously. 
parallel= ""  
. Methods: This will run the parallel tests on all @Test methods in TestNG.
. Tests: All the test cases present inside the <test> tag will run with this value.
. Classes: All the test cases present inside the classes that exist in the XML will run in parallel.

Thread count is basically a number of instances running to execute multiple tests simultaneously or in parallel. The attribute thread-count allows the user to specify how many threads should be run for this execution.

--Thread.currentThread().getId()
parallel="tests" thread-count="2"

-- threadPoolSize: The number of threads we would like to create and run the test parallelly.
==========================
Cross-browser testing : it is the process of testing our website on different browsers and operating systems. With cross-browser testing, we make sure that the site is rendered the same in every browser. We can perform cross-browser testing either manually or in an automated way, but the manual method is very tedious. The reason being that while performing cross-browser testing, we do not only care about the browsers but their different versions and the operating systems too.

Cross-browser testing using TestNG ensure a better performance on different browsers and OS.
================================
. Groups(define) : TestNG Groups allow you to perform groupings of different test methods. Grouping of test methods is required when you want to access the test methods of different classes.
Exclude Tag:  Syntax for exclude tag <exclude name="${TEST_CASE_NAME}" />
Include Tag:  Syntax for include tag <include name="${TEST_CASE_NAME}" />
define
run

=================			

Working of TestNG Annotations :-
1. Launching the browser will be the first step and hence it is included under the @BeforeTest Annotation.
2. Next is the actual test case which verifies the title, and is therefore included in the @Test annotation.
3. Finally, the quit browser test case is considered under the @AfterTest annotation.
-----------------------------------------------------------------------------------------------------------------

Exceptions:-
WebDriver Exceptions in Selenium:
There are many exceptions occurs while using Selenium tool. Here we will discuss most common exceptions.

I have divided the exceptions in different category.

Not Found exception:
=====================
NoSuchWindowException: Webdriver trying to switch on an invalid window.

NoSuchFrameException: WebDriver trying to switch to an invalid frame.

NoSuchElementException: If we have given wrong locator or element is not present is DOM.

NoAlertPresentException: WebDriver trying to switch to an invalid alert.

TimeOutException: When the selenium takes longer time than the given wait time then it throws TimeOutException.

StaleElementReferenceException: If element is no longer present in the DOM due to page got refreshed or a frame/window switched or navigate to another page.


InvalidElementState Exception:
==============================
ElementNotVisibleException: If element is present but visibility is off or If synchronization issue between Selenium and web application or if we have used duplicate xpath then this exception is thrown.

ElementNotSelectableException:  if an element is disable (element is not clicked/selected) .


java.lang.illegalargumentexception in selenium
==============================================
In Selenium, when we have given null or string length is zero in sendKeys() method the n it throw this exception.


Element not visible exception is thrown when:
==============================================

There are many reasons which are mentioned below.

1. If we try to locate a web element which is not visible or hidden on screen then we will get the element not visible exception.
2. Synchronization problem: If Selenium is faster than application or vice versa.
3. If we have used duplicate xpath in our script means more than one web element have same xpath.
4. Sometimes weblement is not on the visible area of the screen (means when we scrolled down the screen then element is visible)

--> how to solve such exceptions
Solution 1: synchroniztion
Solution 2: Always use the unique path that matches only a single element.
Solution 3: We can use try.. catch block to handle this exception.
---------------------------
1. Solution 1: synchroniztion

-- For 1st and 2nd above problem means when element will visible then we will perform operations.
-- Here we can wait until the element is not visible. Once it will visible then we can perform an action.

-- Here we can different wait commands.

*) Thead.sleep(): It is not recommended because we never know in how much time the element will visible on the screen. It might be increasing our test execution.		Thread.sleep(30);
*) Implicit wait: It is also not recommended because it will apply whole line of code in the given test script which increase the execution time.		driver.manage().timeouts().implicitlywait(20, TimeUnit.SECONDS);
*) Explicit wait: It is recommended because it provides different expected conditions which we can use till we want to wait.
		WebDriverWait wait = new WebDriverWait(driver, 20);
wait.until(ExpectedConditions.visibilityOfElementLocated(By.xpath(“Locator”)));

------------------------------

In case of element is not in visibility area of the screen then first we need to scroll the web page using javaScriptExecutor then perform an action.

JavascriptExecutor js = (JavascriptExecutor) driver;
js.executeScript("arguments[0].scrollIntoView(true);", element);


----------------------------------------------------------------------------------------------------------------------

Parameterization –  MS Excel, Properties, DataProvider , scenario outline


-----------------------------------------------------------------------------------------------------------------------
Object Repository :An Object Repository is a map between UI element and its locator. Which can also be written as an Object Map between UI element and the way to find it. In Selenium WebDriver's context it means a Mapping between WebElement and the corresponding locator type and value. create property file by(.properties)

login.username.xpath=.//*[@id='user-name']
login.password.xpath=.//input[@id='password']
login.Signup.xpath=.//input[@id='login-button']

--------------------------------------------------------------------------------------------------------------------
Page Object Model :-Page Object Model (POM) is a design pattern, popularly used in test automation that creates Object Repository for web UI elements. The advantage of the model is that it reduces code duplication and improves test maintenance. For each web page in the application, there should be a corresponding Page Class. This Page class will identify the WebElements of that web page and also contains Page methods which perform operations on those WebElements.	

By is used to locate the elements
-------------------------------------------------------------------------------------------------------------------------

Page Factory : Page Factory is a class provided by Selenium WebDriver to implement the Page Object Model.

-- @FindBy is used to mark a field on a page object to locate the element. using different locators strategies. Additionally, it helps in quickly locating the web elements using one search criteria.

--how -- is another way to locate the elements
-- @FindBys & @FindAll.

First, by specifying both 'How' and 'Using'
@FindBy(how = How.ID, using = "userName")
WebElement username;

Second, by directly using locator(id, XPath, CSS, etc.)  
@FindBy(id="userName")
WebElement username;

--@CacheLookUp : using @CacheLookUp, we can store the web elements in cache memory right after reading for the first time. It fastens our execution and the code, need not look up for the element on the web page and directly references it from memory.
-------------------------------------------------------------------------------------------------------------------------

Screenshots	getScreenShotAs()

--------------------------------------------------------------------------------------------------------------------------
Extent Report  Extent Reports are one of the best built-in ways to generate customizable HTML reports with a pleasing user interface in Selenium web driver.

It is an open source library that can be easily configured with Selenium, thereby making it the best choice for automation testers.

ExtentReports reports = new ExtentReports(“Path of directory to store the resultant HTML file”, true/false);

ExtentTest test = reports.startTest(“TestName”);
